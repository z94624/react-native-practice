{"version":3,"file":"reactotron-mst.es5.js","sources":["../src/reactotron-mst.ts"],"sourcesContent":["// --- Wall of imports ---------------------------------\nimport {\n  addMiddleware,\n  applyAction,\n  applySnapshot,\n  getPath,\n  getSnapshot,\n  getType,\n  isAlive,\n  isProtected,\n  isRoot,\n  IStateTreeNode,\n  IType,\n  onSnapshot,\n  IMiddlewareEvent,\n} from \"mobx-state-tree\"\nimport { Reactotron } from \"reactotron-core-client\"\n\nimport {\n  always,\n  concat,\n  endsWith,\n  filter,\n  flatten,\n  has,\n  identity,\n  is,\n  isEmpty,\n  isNil,\n  keys,\n  map,\n  path,\n  pipe,\n  replace,\n  reject,\n  slice,\n  sortBy,\n  split,\n  uniq,\n  when,\n} from \"ramda\"\n\n// --- Helpers ---------------------------------\n\nconst dotPath = (fullPath: string, o: any) => path(split(\".\", fullPath), o)\nconst isNilOrEmpty = (value: any) => isNil(value) || isEmpty(value)\nconst isReactNativeEvent = (value: any) =>\n  typeof value !== \"undefined\" &&\n  value !== null &&\n  has(\"nativeEvent\", value) &&\n  has(\"target\", value) &&\n  has(\"type\", value)\n\n/**\n * Sadly, this protects calls from endless stack traces.  We have to filter\n * out some things that are known circular troublemakers.\n *\n * @param args A call's args.\n */\nconst convertUnsafeArguments = (args: any) => {\n  const theseArgs = Array.isArray(args) ? args : [args]\n  return theseArgs.map((arg: any) => {\n    if (isReactNativeEvent(arg)) {\n      return \"ReactNativeEvent\"\n    }\n    return arg\n  })\n}\n\n// --- Interfaces ---------------------------------\n\ninterface TrackedNode {\n  /**\n   * The node we are tracking.\n   */\n  node: IStateTreeNode\n\n  /**\n   * The mst model type\n   */\n  modelType: IType<any, any>\n}\n\ninterface NodeTracker {\n  [name: string]: TrackedNode\n}\n\nexport type MstPluginFilter = (event: IMiddlewareEvent) => boolean\n\nexport interface MstPluginOptions {\n  /**\n   * Fine-grain control over what gets sent to the Reactotron app.\n   */\n  filter?: MstPluginFilter\n  /**\n   * When requesting keys, values, or subscribing, configures whether\n   * we talk to the live state object (great for `volatile` state) or the\n   * snapshot.  Defaults to `live`.\n   */\n  queryMode?: \"live\" | \"snapshot\"\n}\n\n// --- The Reactotron Plugin ---------------------------------\n\n/**\n * A factory function for creating the plugin.\n *\n * @param opts Plugin options.\n */\nexport function mst(opts: MstPluginOptions = {}) {\n  /**\n   * The mobx-state-tree Reactotron plugin.\n   *\n   * @param reactotron The reactotron instance we're attaching to.\n   */\n  function plugin(reactotron: Reactotron) {\n    // --- Plugin-scoped variables ---------------------------------\n\n    // the stores we're tracking\n    const trackedNodes: NodeTracker = {}\n\n    // are we in the middle of restoring?  this will prevent\n    // extra @APPLY_SNAPSHOT signals from being sent\n    let restoring: boolean = false\n\n    // a list of subscriptions the client is subscribing to\n    let subscriptions: string[] = []\n\n    const mstFilter = opts.filter ? opts.filter : () => true\n\n    // --- Connecting MST to Reactotron ---------------------------------\n\n    /**\n     * The entry point for integrating a mobx-state-tree node with Reactotron. Currently\n     * one 1 root node is supported.\n     *\n     * @param node The mobx-state-tree node to track\n     * @param nodeName The name to call it if we have more than 1.\n     */\n    function trackMstNode(node: IStateTreeNode, nodeName: string = \"default\") {\n      // sanity\n      if (!node) {\n        return { kind: \"required\" }\n      }\n\n      // prevent double tracking\n      if (trackedNodes[nodeName]) {\n        return { kind: \"already-tracking\" }\n      }\n\n      try {\n        // grab the mst model type\n        const modelType = getType<any, any>(node)\n\n        // we only want types\n        if (modelType.isType) {\n          try {\n            attachReactotronToMstNode(node)\n            // track this\n            trackedNodes[nodeName] = { node, modelType }\n            return { kind: \"ok\" }\n          } catch (e) {\n            return { kind: \"tracking-error\", message: e.message }\n          }\n        } else {\n          return { kind: \"invalid-node\" }\n        }\n      } catch (e) {\n        return { kind: \"invalid-node\" }\n      }\n    }\n\n    /**\n     * Connects a mst tree node to Reactotron.\n     *\n     * @param node The node we want to track.\n     * @param nodeName What to call this node.\n     */\n    function attachReactotronToMstNode(node: IStateTreeNode, nodeName?: string) {\n      // whenever the snapshot changes, send subscriptions\n      onSnapshot(node, sendSubscriptions)\n\n      /**\n       * Make some middleware that allows us to track actions.\n       */\n      addMiddleware(node, (call, next) => {\n        // only actions for now\n        const skip = call.type !== \"action\"\n\n        // skip this middleware?\n        if (skip) {\n          return next(call)\n        }\n\n        // userland opt-out\n        const shouldSend = mstFilter(call)\n        if (!shouldSend) {\n          return next(call)\n        }\n\n        // grab the arguments\n        const args = convertUnsafeArguments(call.args)\n        const path = getPath(call.context)\n\n        // action related data\n        const action = { args: args, name: call.name, path }\n\n        // mst internal data\n        const mstPayload = {\n          id: call.id,\n          parentId: call.parentId,\n          rootId: call.rootId,\n          type: call.type,\n          modelType: getType(node),\n          alive: isAlive(node),\n          root: isRoot(node),\n          protected: isProtected(node),\n        }\n\n        // start a timer\n        const elapsed = reactotron.startTimer()\n\n        // chain off to the next middleware\n        const result = next(call)\n\n        // measure the speed\n        const ms = elapsed()\n\n        // add nice display name\n        const displayPath = replace(/^\\./, \"\", replace(/\\//g, \".\", path))\n        let name = replace(/^\\./, \"\", `${nodeName ? nodeName : \"\"}${displayPath}.${call.name}()`)\n        name = replace(\"/\", \".\", name)\n        // fire this off to reactotron\n        if (!restoring) {\n          reactotron.send(\"state.action.complete\", {\n            name,\n            action,\n            mst: mstPayload,\n            ms,\n          })\n        }\n\n        // return the result of the next middlware\n        return result\n      })\n    }\n\n    // --- Reactotron Hooks ---------------------------------\n\n    /**\n     * A backup of state has been requested. Lets serialize the current\n     * state and send it up to the app.\n     *\n     * @param command A reactotron command.\n     */\n    function backup(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      if (trackedNode && trackedNode.node) {\n        const state = getSnapshot(trackedNode.node)\n        reactotron.send(\"state.backup.response\", { state })\n      }\n    }\n\n    /**\n     * Update the current state with one that was sent to us by the\n     * Reactotron app.\n     *\n     * @param command A reactotron command.\n     */\n    function restore(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const state = command && command.payload && command.payload.state\n      if (trackedNode && trackedNode.node) {\n        const { node } = trackedNode\n        restoring = true\n        applySnapshot(node, state)\n        restoring = false\n      }\n    }\n\n    /**\n     * Applies an action to the mst node which was sent from the Reactotron\n     * app. It can be a replayed action we emitted earlier, or one the user\n     * has typed in manually.\n     *\n     * @param command A reactotron command.\n     */\n    function dispatchAction(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const action = command && command.payload && command.payload.action\n      if (trackedNode && trackedNode.node && action) {\n        const { node } = trackedNode\n        try {\n          applyAction(node, action)\n        } catch {\n          // TODO: should we return a message?\n        }\n      }\n    }\n\n    /**\n     * Subscribes to some paths in state. Allows the user to track a subset of\n     * data within the state that will be sent to them every time it changes.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function subscribe(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const paths: string[] = (command && command.payload && command.payload.paths) || []\n\n      if (paths) {\n        subscriptions = uniq(flatten(paths))\n      }\n\n      if (trackedNode && trackedNode.node) {\n        const state =\n          opts.queryMode === \"snapshot\" ? getSnapshot(trackedNode.node) : trackedNode.node\n        sendSubscriptions(state)\n      }\n    }\n\n    /**\n     * Given a path somewhere within the tree, list the keys found if it is an object.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function requestKeys(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const atPath: string = (command && command.payload && command.payload.path) || []\n      if (trackedNode && trackedNode.node && atPath) {\n        const state = getSnapshot(trackedNode.node)\n        if (isNilOrEmpty(atPath)) {\n          reactotron.stateKeysResponse(null, keys(state))\n        } else {\n          const keyList = keys(dotPath(atPath, state))\n          reactotron.stateKeysResponse(atPath, keyList)\n        }\n      }\n    }\n\n    /**\n     * Gets the current value located at the path within the state tree.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function requestValues(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const atPath: string = (command && command.payload && command.payload.path) || []\n      if (trackedNode && trackedNode.node && atPath) {\n        const state = getSnapshot(trackedNode.node)\n        if (isNilOrEmpty(atPath)) {\n          reactotron.stateValuesResponse(null, state)\n        } else {\n          reactotron.stateValuesResponse(atPath, dotPath(atPath, state))\n        }\n      }\n    }\n\n    /**\n     * Sends all subscribed values to the Reactotron app.\n     *\n     * @param node The tree to grab the state data from\n     */\n    function sendSubscriptions(state: any) {\n      // this is unreadable\n      const changes = (pipe as any)(\n        map(when(isNil, always(\"\"))) as any,\n        filter(endsWith(\".*\")),\n        map((key: string) => {\n          const keyMinusWildcard = slice(0, -2, key)\n          const value = dotPath(keyMinusWildcard, state)\n          if (is(Object, value) && !isNilOrEmpty(value)) {\n            return pipe(\n              keys,\n              map(key => `${keyMinusWildcard}.${key}`)\n            )(value || {})\n          }\n          return []\n        }) as any,\n        concat(map(when(isNil, always(\"\")), subscriptions)),\n        flatten,\n        reject(endsWith(\".*\")) as any,\n        uniq as any,\n        sortBy(identity) as any,\n        map((key: string) => ({\n          path: key,\n          value: isNilOrEmpty(key) ? state : dotPath(key, state),\n        }))\n      )(subscriptions)\n\n      reactotron.stateValuesChange(changes)\n    }\n\n    // --- Reactotron Hooks ---------------------------------\n\n    // maps inbound commands to functions to run\n    const COMMAND_MAP: { [name: string]: (command: any) => void } = {\n      \"state.backup.request\": backup,\n      \"state.restore.request\": restore,\n      \"state.action.dispatch\": dispatchAction,\n      \"state.values.subscribe\": subscribe,\n      \"state.keys.request\": requestKeys,\n      \"state.values.request\": requestValues,\n    }\n\n    /**\n     * Fires when we receive a command from the reactotron app.\n     */\n    function onCommand(command: any) {\n      // lookup the command and execute\n      const handler = COMMAND_MAP[command && command.type]\n      handler && handler(command)\n    }\n\n    // --- Reactotron plugin interface ---------------------------------\n\n    return {\n      // Fires when we receive a command from the Reactotron app.\n      onCommand,\n\n      // All keys in this object will be attached to the main Reactotron instance\n      // and available to be called directly.\n      features: { trackMstNode },\n    }\n  }\n\n  return plugin\n}\n\ndeclare module \"reactotron-core-client\" {\n  // eslint-disable-next-line import/export\n  export interface Reactotron {\n    trackMstNode?: (node: IStateTreeNode, nodeName?: string) => { kind: string; message?: string }\n  }\n}\n"],"names":["dotPath","fullPath","o","path","split","isNilOrEmpty","value","isNil","isEmpty","isReactNativeEvent","has","convertUnsafeArguments","args","theseArgs","Array","isArray","map","arg","mst","opts","reactotron","attachReactotronToMstNode","node","nodeName","onSnapshot","sendSubscriptions","addMiddleware","call","next","skip","type","shouldSend","mstFilter","getPath","context","action","name","mstPayload","id","parentId","rootId","modelType","getType","alive","isAlive","root","isRoot","protected","isProtected","elapsed","startTimer","result","ms","displayPath","replace","restoring","send","state","changes","pipe","when","always","filter","endsWith","key","keyMinusWildcard","slice","is","Object","keys","concat","subscriptions","flatten","reject","uniq","sortBy","identity","stateValuesChange","trackedNodes","COMMAND_MAP","command","trackedNode","mstNodeName","getSnapshot","payload","applySnapshot","applyAction","paths","queryMode","atPath","stateKeysResponse","keyList","stateValuesResponse","onCommand","handler","features","trackMstNode","kind","isType","e","message"],"mappings":"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"}