{"version":3,"file":"reactotron-mst.umd.js","sources":["../src/reactotron-mst.ts"],"sourcesContent":["// --- Wall of imports ---------------------------------\nimport {\n  addMiddleware,\n  applyAction,\n  applySnapshot,\n  getPath,\n  getSnapshot,\n  getType,\n  isAlive,\n  isProtected,\n  isRoot,\n  IStateTreeNode,\n  IType,\n  onSnapshot,\n  IMiddlewareEvent,\n} from \"mobx-state-tree\"\nimport { Reactotron } from \"reactotron-core-client\"\n\nimport {\n  always,\n  concat,\n  endsWith,\n  filter,\n  flatten,\n  has,\n  identity,\n  is,\n  isEmpty,\n  isNil,\n  keys,\n  map,\n  path,\n  pipe,\n  replace,\n  reject,\n  slice,\n  sortBy,\n  split,\n  uniq,\n  when,\n} from \"ramda\"\n\n// --- Helpers ---------------------------------\n\nconst dotPath = (fullPath: string, o: any) => path(split(\".\", fullPath), o)\nconst isNilOrEmpty = (value: any) => isNil(value) || isEmpty(value)\nconst isReactNativeEvent = (value: any) =>\n  typeof value !== \"undefined\" &&\n  value !== null &&\n  has(\"nativeEvent\", value) &&\n  has(\"target\", value) &&\n  has(\"type\", value)\n\n/**\n * Sadly, this protects calls from endless stack traces.  We have to filter\n * out some things that are known circular troublemakers.\n *\n * @param args A call's args.\n */\nconst convertUnsafeArguments = (args: any) => {\n  const theseArgs = Array.isArray(args) ? args : [args]\n  return theseArgs.map((arg: any) => {\n    if (isReactNativeEvent(arg)) {\n      return \"ReactNativeEvent\"\n    }\n    return arg\n  })\n}\n\n// --- Interfaces ---------------------------------\n\ninterface TrackedNode {\n  /**\n   * The node we are tracking.\n   */\n  node: IStateTreeNode\n\n  /**\n   * The mst model type\n   */\n  modelType: IType<any, any>\n}\n\ninterface NodeTracker {\n  [name: string]: TrackedNode\n}\n\nexport type MstPluginFilter = (event: IMiddlewareEvent) => boolean\n\nexport interface MstPluginOptions {\n  /**\n   * Fine-grain control over what gets sent to the Reactotron app.\n   */\n  filter?: MstPluginFilter\n  /**\n   * When requesting keys, values, or subscribing, configures whether\n   * we talk to the live state object (great for `volatile` state) or the\n   * snapshot.  Defaults to `live`.\n   */\n  queryMode?: \"live\" | \"snapshot\"\n}\n\n// --- The Reactotron Plugin ---------------------------------\n\n/**\n * A factory function for creating the plugin.\n *\n * @param opts Plugin options.\n */\nexport function mst(opts: MstPluginOptions = {}) {\n  /**\n   * The mobx-state-tree Reactotron plugin.\n   *\n   * @param reactotron The reactotron instance we're attaching to.\n   */\n  function plugin(reactotron: Reactotron) {\n    // --- Plugin-scoped variables ---------------------------------\n\n    // the stores we're tracking\n    const trackedNodes: NodeTracker = {}\n\n    // are we in the middle of restoring?  this will prevent\n    // extra @APPLY_SNAPSHOT signals from being sent\n    let restoring: boolean = false\n\n    // a list of subscriptions the client is subscribing to\n    let subscriptions: string[] = []\n\n    const mstFilter = opts.filter ? opts.filter : () => true\n\n    // --- Connecting MST to Reactotron ---------------------------------\n\n    /**\n     * The entry point for integrating a mobx-state-tree node with Reactotron. Currently\n     * one 1 root node is supported.\n     *\n     * @param node The mobx-state-tree node to track\n     * @param nodeName The name to call it if we have more than 1.\n     */\n    function trackMstNode(node: IStateTreeNode, nodeName: string = \"default\") {\n      // sanity\n      if (!node) {\n        return { kind: \"required\" }\n      }\n\n      // prevent double tracking\n      if (trackedNodes[nodeName]) {\n        return { kind: \"already-tracking\" }\n      }\n\n      try {\n        // grab the mst model type\n        const modelType = getType<any, any>(node)\n\n        // we only want types\n        if (modelType.isType) {\n          try {\n            attachReactotronToMstNode(node)\n            // track this\n            trackedNodes[nodeName] = { node, modelType }\n            return { kind: \"ok\" }\n          } catch (e) {\n            return { kind: \"tracking-error\", message: e.message }\n          }\n        } else {\n          return { kind: \"invalid-node\" }\n        }\n      } catch (e) {\n        return { kind: \"invalid-node\" }\n      }\n    }\n\n    /**\n     * Connects a mst tree node to Reactotron.\n     *\n     * @param node The node we want to track.\n     * @param nodeName What to call this node.\n     */\n    function attachReactotronToMstNode(node: IStateTreeNode, nodeName?: string) {\n      // whenever the snapshot changes, send subscriptions\n      onSnapshot(node, sendSubscriptions)\n\n      /**\n       * Make some middleware that allows us to track actions.\n       */\n      addMiddleware(node, (call, next) => {\n        // only actions for now\n        const skip = call.type !== \"action\"\n\n        // skip this middleware?\n        if (skip) {\n          return next(call)\n        }\n\n        // userland opt-out\n        const shouldSend = mstFilter(call)\n        if (!shouldSend) {\n          return next(call)\n        }\n\n        // grab the arguments\n        const args = convertUnsafeArguments(call.args)\n        const path = getPath(call.context)\n\n        // action related data\n        const action = { args: args, name: call.name, path }\n\n        // mst internal data\n        const mstPayload = {\n          id: call.id,\n          parentId: call.parentId,\n          rootId: call.rootId,\n          type: call.type,\n          modelType: getType(node),\n          alive: isAlive(node),\n          root: isRoot(node),\n          protected: isProtected(node),\n        }\n\n        // start a timer\n        const elapsed = reactotron.startTimer()\n\n        // chain off to the next middleware\n        const result = next(call)\n\n        // measure the speed\n        const ms = elapsed()\n\n        // add nice display name\n        const displayPath = replace(/^\\./, \"\", replace(/\\//g, \".\", path))\n        let name = replace(/^\\./, \"\", `${nodeName ? nodeName : \"\"}${displayPath}.${call.name}()`)\n        name = replace(\"/\", \".\", name)\n        // fire this off to reactotron\n        if (!restoring) {\n          reactotron.send(\"state.action.complete\", {\n            name,\n            action,\n            mst: mstPayload,\n            ms,\n          })\n        }\n\n        // return the result of the next middlware\n        return result\n      })\n    }\n\n    // --- Reactotron Hooks ---------------------------------\n\n    /**\n     * A backup of state has been requested. Lets serialize the current\n     * state and send it up to the app.\n     *\n     * @param command A reactotron command.\n     */\n    function backup(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      if (trackedNode && trackedNode.node) {\n        const state = getSnapshot(trackedNode.node)\n        reactotron.send(\"state.backup.response\", { state })\n      }\n    }\n\n    /**\n     * Update the current state with one that was sent to us by the\n     * Reactotron app.\n     *\n     * @param command A reactotron command.\n     */\n    function restore(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const state = command && command.payload && command.payload.state\n      if (trackedNode && trackedNode.node) {\n        const { node } = trackedNode\n        restoring = true\n        applySnapshot(node, state)\n        restoring = false\n      }\n    }\n\n    /**\n     * Applies an action to the mst node which was sent from the Reactotron\n     * app. It can be a replayed action we emitted earlier, or one the user\n     * has typed in manually.\n     *\n     * @param command A reactotron command.\n     */\n    function dispatchAction(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const action = command && command.payload && command.payload.action\n      if (trackedNode && trackedNode.node && action) {\n        const { node } = trackedNode\n        try {\n          applyAction(node, action)\n        } catch {\n          // TODO: should we return a message?\n        }\n      }\n    }\n\n    /**\n     * Subscribes to some paths in state. Allows the user to track a subset of\n     * data within the state that will be sent to them every time it changes.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function subscribe(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const paths: string[] = (command && command.payload && command.payload.paths) || []\n\n      if (paths) {\n        subscriptions = uniq(flatten(paths))\n      }\n\n      if (trackedNode && trackedNode.node) {\n        const state =\n          opts.queryMode === \"snapshot\" ? getSnapshot(trackedNode.node) : trackedNode.node\n        sendSubscriptions(state)\n      }\n    }\n\n    /**\n     * Given a path somewhere within the tree, list the keys found if it is an object.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function requestKeys(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const atPath: string = (command && command.payload && command.payload.path) || []\n      if (trackedNode && trackedNode.node && atPath) {\n        const state = getSnapshot(trackedNode.node)\n        if (isNilOrEmpty(atPath)) {\n          reactotron.stateKeysResponse(null, keys(state))\n        } else {\n          const keyList = keys(dotPath(atPath, state))\n          reactotron.stateKeysResponse(atPath, keyList)\n        }\n      }\n    }\n\n    /**\n     * Gets the current value located at the path within the state tree.\n     *\n     * @param command The command received from the reactotron app.\n     */\n    function requestValues(command: any) {\n      const trackedNode = trackedNodes[command.mstNodeName || \"default\"]\n      const atPath: string = (command && command.payload && command.payload.path) || []\n      if (trackedNode && trackedNode.node && atPath) {\n        const state = getSnapshot(trackedNode.node)\n        if (isNilOrEmpty(atPath)) {\n          reactotron.stateValuesResponse(null, state)\n        } else {\n          reactotron.stateValuesResponse(atPath, dotPath(atPath, state))\n        }\n      }\n    }\n\n    /**\n     * Sends all subscribed values to the Reactotron app.\n     *\n     * @param node The tree to grab the state data from\n     */\n    function sendSubscriptions(state: any) {\n      // this is unreadable\n      const changes = (pipe as any)(\n        map(when(isNil, always(\"\"))) as any,\n        filter(endsWith(\".*\")),\n        map((key: string) => {\n          const keyMinusWildcard = slice(0, -2, key)\n          const value = dotPath(keyMinusWildcard, state)\n          if (is(Object, value) && !isNilOrEmpty(value)) {\n            return pipe(\n              keys,\n              map(key => `${keyMinusWildcard}.${key}`)\n            )(value || {})\n          }\n          return []\n        }) as any,\n        concat(map(when(isNil, always(\"\")), subscriptions)),\n        flatten,\n        reject(endsWith(\".*\")) as any,\n        uniq as any,\n        sortBy(identity) as any,\n        map((key: string) => ({\n          path: key,\n          value: isNilOrEmpty(key) ? state : dotPath(key, state),\n        }))\n      )(subscriptions)\n\n      reactotron.stateValuesChange(changes)\n    }\n\n    // --- Reactotron Hooks ---------------------------------\n\n    // maps inbound commands to functions to run\n    const COMMAND_MAP: { [name: string]: (command: any) => void } = {\n      \"state.backup.request\": backup,\n      \"state.restore.request\": restore,\n      \"state.action.dispatch\": dispatchAction,\n      \"state.values.subscribe\": subscribe,\n      \"state.keys.request\": requestKeys,\n      \"state.values.request\": requestValues,\n    }\n\n    /**\n     * Fires when we receive a command from the reactotron app.\n     */\n    function onCommand(command: any) {\n      // lookup the command and execute\n      const handler = COMMAND_MAP[command && command.type]\n      handler && handler(command)\n    }\n\n    // --- Reactotron plugin interface ---------------------------------\n\n    return {\n      // Fires when we receive a command from the Reactotron app.\n      onCommand,\n\n      // All keys in this object will be attached to the main Reactotron instance\n      // and available to be called directly.\n      features: { trackMstNode },\n    }\n  }\n\n  return plugin\n}\n\ndeclare module \"reactotron-core-client\" {\n  // eslint-disable-next-line import/export\n  export interface Reactotron {\n    trackMstNode?: (node: IStateTreeNode, nodeName?: string) => { kind: string; message?: string }\n  }\n}\n"],"names":["dotPath","fullPath","o","path","split","isNilOrEmpty","value","isNil","isEmpty","isReactNativeEvent","has","convertUnsafeArguments","args","theseArgs","Array","isArray","map","arg","opts","reactotron","attachReactotronToMstNode","node","nodeName","onSnapshot","sendSubscriptions","addMiddleware","call","next","skip","type","shouldSend","mstFilter","getPath","context","action","name","mstPayload","id","parentId","rootId","modelType","getType","alive","isAlive","root","isRoot","protected","isProtected","elapsed","startTimer","result","ms","displayPath","replace","restoring","send","mst","state","changes","pipe","when","always","filter","endsWith","key","keyMinusWildcard","slice","is","Object","keys","concat","subscriptions","flatten","reject","uniq","sortBy","identity","stateValuesChange","trackedNodes","COMMAND_MAP","command","trackedNode","mstNodeName","getSnapshot","payload","applySnapshot","applyAction","paths","queryMode","atPath","stateKeysResponse","keyList","stateValuesResponse","onCommand","handler","features","trackMstNode","kind","isType","e","message"],"mappings":"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"}