"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findPackageDependencyDir = exports.findPackageDir = exports.findPackage = exports.writePackage = exports.readPackage = exports.isPackageManifest = exports.getMangledPackageName = exports.parsePackageRef = void 0;
const properties_1 = require("@rnx-kit/tools-language/properties");
const find_up_1 = __importDefault(require("find-up"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const pkg_dir_1 = __importDefault(require("pkg-dir"));
const pkg_up_1 = __importDefault(require("pkg-up"));
/**
 * Parse a package reference string. An example reference is the `name`
 * property found in `package.json`.
 *
 * @param r Package reference string
 * @returns Parsed package reference object
 */
function parsePackageRef(r) {
    if (r.startsWith("@")) {
        const indexSeparator = r.indexOf("/");
        // The separator must start from position >= 2 to ensure that it is '@'
        // and at least one other character. Further, the separator must have
        // at least 1 character following it, before the end of the string.
        if (indexSeparator < 2 || indexSeparator + 2 >= r.length) {
            throw new Error(`Invalid package reference: "${r}"`);
        }
        return {
            scope: r.substring(0, indexSeparator),
            name: r.substring(indexSeparator + 1),
        };
    }
    if (!r) {
        throw new Error(`Invalid package reference: "${r}"`);
    }
    return { name: r };
}
exports.parsePackageRef = parsePackageRef;
/**
 * Get the mangled name for a package reference.
 *
 * @param ref Package reference
 * @returns Mangled name
 */
function getMangledPackageName(ref) {
    if (ref.scope) {
        return ref.scope.slice(1) + "__" + ref.name;
    }
    return ref.name;
}
exports.getMangledPackageName = getMangledPackageName;
/**
 * Determine if the given object is a `package.json` manifest.
 *
 * @param manifest Object to evaluate
 * @returns `true` if the object is a manifest
 */
function isPackageManifest(manifest) {
    return (typeof manifest === "object" &&
        manifest !== null &&
        "name" in manifest &&
        "version" in manifest);
}
exports.isPackageManifest = isPackageManifest;
/**
 * Resolve a package path to a file reference by appending `package.json`, if needed.
 *
 * @param pkgPath Package path. May contain `package.json`.
 * @returns File reference to `package.json`
 */
function resolvePackagePath(pkgPath) {
    if (path.basename(pkgPath).toLowerCase() !== "package.json") {
        return path.join(pkgPath, "package.json");
    }
    return pkgPath;
}
/**
 * Read a `package.json` manifest from a file.
 *
 * @param pkgPath Either a path directly to the target `package.json` file, or the directory containing it.
 * @returns Package manifest
 */
function readPackage(pkgPath) {
    const pkgFile = resolvePackagePath(pkgPath);
    return JSON.parse(fs.readFileSync(pkgFile, "utf-8"));
}
exports.readPackage = readPackage;
/**
 * Write a `package.json` manifest to a file.
 *
 * @param pkgPath Either a path directly to the target `package.json` file, or the directory containing it.
 * @param manifest Package manifest
 * @param space Indentation to apply to the output
 */
function writePackage(pkgPath, manifest, space = "  ") {
    const pkgFile = resolvePackagePath(pkgPath);
    fs.writeFileSync(pkgFile, JSON.stringify(manifest, undefined, space) + "\n", "utf-8");
}
exports.writePackage = writePackage;
/**
 * Find the nearest `package.json` manifest file. Search upward through all
 * parent directories.
 *
 * If a starting directory is given, use it. Otherwise, use the current working
 * directory.
 *
 * @param startDir Optional starting directory for the search. If not given, the current directory is used.
 * @returns Path to `package.json`, or `undefined` if not found.
 */
function findPackage(startDir) {
    var _a;
    return (_a = pkg_up_1.default.sync({ cwd: startDir ? startDir : process.cwd() })) !== null && _a !== void 0 ? _a : undefined;
}
exports.findPackage = findPackage;
/**
 * Find the parent directory of the nearest `package.json` manifest file. Search
 * upward through all parent directories.
 *
 * If a starting directory is given, use it. Otherwise, use the current working
 * directory.
 *
 * @param startDir Optional starting directory for the search. If not given, the current directory is used.
 * @returns Path to `package.json`, or `undefined` if not found.
 */
function findPackageDir(startDir) {
    var _a;
    return (_a = pkg_dir_1.default.sync(startDir ? startDir : process.cwd())) !== null && _a !== void 0 ? _a : undefined;
}
exports.findPackageDir = findPackageDir;
/**
 * Find the package dependency's directory, starting from the given directory
 * and moving outward, through all parent directories.
 *
 * Package dependencies exist under 'node_modules/[`scope`]/[`name`]'.
 *
 * @param ref Package dependency reference
 * @param options Options which control the search
 * @returns Path to the package dependency's directory, or `undefined` if not found.
 */
function findPackageDependencyDir(ref, options) {
    var _a;
    const pkgName = typeof ref === "string" ? ref : path.join((_a = ref.scope) !== null && _a !== void 0 ? _a : "", ref.name);
    const packageDir = find_up_1.default.sync(path.join("node_modules", pkgName), Object.assign(Object.assign({}, (0, properties_1.pickValues)(options !== null && options !== void 0 ? options : {}, ["startDir", "allowSymlinks"], ["cwd", "allowSymlinks"])), { type: "directory" }));
    if (!packageDir || !(options === null || options === void 0 ? void 0 : options.resolveSymlinks)) {
        return packageDir;
    }
    return fs.lstatSync(packageDir).isSymbolicLink()
        ? path.resolve(path.dirname(packageDir), fs.readlinkSync(packageDir))
        : packageDir;
}
exports.findPackageDependencyDir = findPackageDependencyDir;
//# sourceMappingURL=package.js.map