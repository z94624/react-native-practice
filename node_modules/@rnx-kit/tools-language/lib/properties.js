"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasProperty = exports.extendObjectArray = exports.extendObject = exports.pickValues = exports.pickValue = void 0;
/**
 * Pick the value for property `key` from `obj` and return it in a new object.
 * If `name` is given, use it in the new object, instead of `key`.
 *
 * If `key` was not found or its value is `undefined`, nothing will be picked.
 *
 * @param obj Object to pick from
 * @param key Key to pick
 * @param name Optional name to use in the output object
 * @returns An object containing a single `name` property and the picked value, or `undefined` if nothing was picked.
 */
function pickValue(obj, key, name) {
    const value = obj[key];
    return typeof value !== "undefined" ? { [name !== null && name !== void 0 ? name : key]: value } : undefined;
}
exports.pickValue = pickValue;
/**
 * Pick the value for each `key` property from `obj` and return each one in a new object.
 * If `names` are given, use them in the new object, instead of `keys`.
 *
 * If any `key` was not found or its value was `undefined`, nothing will be picked for that key.
 *
 * @param obj Object to pick from
 * @param keys Keys to pick
 * @param names Optional names to use in the output object
 * @returns A new object containing a each `name` property and the picked value, or `undefined` if no keys were picked.
 */
function pickValues(obj, keys, names) {
    const finalNames = names !== null && names !== void 0 ? names : keys;
    const results = {};
    let pickedValue = false;
    for (let index = 0; index < keys.length; ++index) {
        const value = obj[keys[index]];
        if (typeof value !== "undefined") {
            results[finalNames[index].toString()] = value;
            pickedValue = true;
        }
    }
    return pickedValue ? results : undefined;
}
exports.pickValues = pickValues;
/**
 * Add properties to an object, changing it from its current type to an extended type.
 *
 * Properties are added in-place, and the original object reference is returned as the extended type.
 *
 * @param obj Object to extend
 * @param extendedProps Properties to add to the object, extending it
 * @returns The original object reference as the extended type
 */
function extendObject(obj, extendedProps) {
    return Object.assign(obj, extendedProps);
}
exports.extendObject = extendObject;
/**
 * Add properties to each object in an array, changing the object from its current type to an extended type.
 *
 * Properties are added in-place, and the original object array reference is returned as the extended array type.
 *
 * @param arr Array of objects to extend
 * @param extendedProps Properties to add to each object in the array, extending it
 * @returns The original object array reference as the extended array type
 */
function extendObjectArray(arr, extendedProps) {
    arr.map((obj) => Object.assign(obj, extendedProps));
    return arr;
}
exports.extendObjectArray = extendObjectArray;
/**
 * Returns whether `property` exists in `obj`.
 *
 * @param obj The object to examine
 * @param property The property to look for
 * @returns Whether `obj` contains `property`
 */
function hasProperty(obj, property) {
    return typeof obj === "object" && obj !== null && property in obj;
}
exports.hasProperty = hasProperty;
//# sourceMappingURL=properties.js.map